import { createResolver } from '@nuxt/kit'
import fs from 'fs'
import type { Nuxt } from 'nuxt/schema'
import { join } from 'path'
import { Node, Project, type SourceFile } from 'ts-morph'
import { useShopinvaderLogger } from './logger'
const UNICODE_GREEN = '\x1b[32m'
const UNICODE_RESET = '\x1b[0m'
const warning =
  '// Do NOT modify this file: it is automatically generated by ShopInvader Module.\n// =============================================================================\n'
const logger = useShopinvaderLogger()

interface TSFile {
  name: string
  target: 'index' | 'originals'
  imports: string[]
  path: string
  nodeType: string
  content: string
}
/**
 * return the list of models or services imported in a source file
 * @param type 'models' or 'services'
 * @param sourceFile SourceFile
 * @returns string[]
 */
function extractTSImports(type: string, sourceFile: SourceFile): string[] {
  return sourceFile
    .getImportDeclarations()
    .filter((i) => i.getModuleSpecifierValue()?.includes(`#${type}`))
    .reduce((acc, i) => {
      const names = i.getNamedImports().map((i) => i.getName())
      for (const name of names) {
        if (!acc.includes(name)) {
          acc.push(name)
        }
      }
      return acc
    }, [] as string[])
}

/**
 * extract class from a file
 * @param type 'models' or 'services'
 * @param files
 * @returns
 */
function extractTsClass(type: string, filePaths: string[]): TSFile[] {
  const declarations: TSFile[] = []
  const project = new Project({
    skipFileDependencyResolution: true,
    skipLoadingLibFiles: true,
    skipAddingFilesFromTsConfig: true
  })
  const excludedFiles = []
  for (const path of filePaths) {
    excludedFiles.push(`${path}/index.ts`)
    excludedFiles.push(`${path}/originals.ts`)
  }
  project.addSourceFilesAtPaths(filePaths.map((f) => `${f}/**/*{.d.ts,.ts}`))

  const sourceFiles = project.getSourceFiles()
  for (const sourceFile of sourceFiles) {
    if (
      !excludedFiles.includes(sourceFile.getFilePath()) &&
      !sourceFile.getFilePath().includes('index.ts')
    ) {
      const imports = extractTSImports(type, sourceFile)
      for (const [name, [declaration]] of sourceFile.getExportedDeclarations()) {
        // Add the class/interface to the list
        declarations.push({
          name,
          target: declarations.some((d) => d.name === name) ? 'originals' : 'index',
          path: sourceFile.getFilePath(),
          content: '',
          imports,
          nodeType:
            Node.isInterfaceDeclaration(declaration) || Node.isTypeAliasDeclaration(declaration)
              ? 'interface'
              : 'class'
        })
      }
    }
  }

  /** Sort by dependencies (imports) */
  return declarations
    .sort((a, b) => {
      return a.imports.length > b.imports.length ? 1 : -1
    })
    .reduce((acc, file) => {
      if (file.imports.length > 0) {
        for (const i of file.imports) {
          if (!acc.some((f) => f.name === i)) {
            const dep = declarations.find((f) => f.name === i)
            if (dep) {
              acc.push(dep)
            }
          }
        }
      }
      if (!acc.some((f) => f.name === file.name && f.path === file.path)) {
        acc.push(file)
      }
      return acc
    }, [] as TSFile[])
}

async function writeFileContent(
  applicationRoot: string,
  type: string,
  name: string,
  content: string
): Promise<string> {
  const dir = applicationRoot + '/' + type
  // Create the directory if it does not exist
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir)
  }
  const filepath = `${dir}/${name}.ts`
  // Read the current file content if the file exists
  if (fs.existsSync(filepath)) {
    const currentContent = fs.readFileSync(filepath, 'utf8')
    // Avoid writing the file if the content is the same
    if (currentContent === content) {
      return filepath
    }
  }
  fs.writeFileSync(filepath, content, 'utf8')
  logger.log(`[ShopInvader] BUILD - new ${type} ${name} file saved.`)
  return filepath
}

async function buildindexFileContent(
  nuxt: Nuxt,
  type: string
): Promise<{ index: string; originals: string }> {
  const contents = {
    index: warning,
    originals: warning
  }
  const layers = nuxt.options._layers
  if (layers.length === 0) {
    return contents
  }
  // Build list of all files in layers
  const filePaths: string[] = []
  for (const layer of layers) {
    const { resolve } = createResolver(layer.cwd)
    filePaths.push(resolve(`./${type}`))
  }
  // Extract classes/interfaces from files
  const files = extractTsClass(type, filePaths)
  // Build the content for the index file
  contents.index += files
    .filter((f) => f.target === 'index')
    .map((f) => {
      const type = f.nodeType == 'interface' ? 'type ' : ''
      return `export ${type} { ${f.name} } from '${f.path.replace('.ts', '')}'`
    })
    .join('\n')

  // Add all originals file
  const originalsFiles = files.filter((f) => f.target === 'originals')
  contents.originals += originalsFiles
    .map((f) => {
      const type = f.nodeType == 'interface' ? 'type ' : ''
      return `export ${type} { ${f.name} } from '${f.path.replace('.ts', '')}'`
    })
    .join('\n')
  if (originalsFiles.length > 0) {
    logger.log(
      `[ShopInvader] BUILD - Some ShopInvader model are overrided by your custom model. You can use ${UNICODE_GREEN}import * as OriginalModels from #models/originals ${UNICODE_RESET} to access the originals.`
    )
  }
  return contents
}

// Scan all layers for models and services and create a single file for each via the prepare:types Nuxt hook
export const addModelsServicesTemplates = async (nuxt: Nuxt) => {
  const applicationRoot = nuxt.options.srcDir
  const types = ['models', 'services']
  const layers = nuxt.options._layers
  let alias = {}

  for (const type of types) {
    // Write index files
    const content = await buildindexFileContent(nuxt, type)
    logger.log(`[ShopInvader] BUILD - Checking index ${type} file`)
    const indexFile = await writeFileContent(applicationRoot, type, 'index', content.index)
    await writeFileContent(applicationRoot, type, 'originals', content.originals)
    if (layers.length > 0) {
      for (const layer of layers) {
        if (layer.cwd !== applicationRoot) {
          await writeFileContent(
            layer.cwd,
            type,
            'index',
            `${warning}export * from '${indexFile.replace('.ts', '')}'\n`
          )
        }
      }
    }
    // Add alias to nuxt options
    alias = {
      ...alias,
      [`#${type}`]: join(applicationRoot, type)
    }
  }
  // Add alias to nuxt options
  nuxt.options.alias = {
    ...alias,
    ...nuxt.options.alias
  }

  // Add hook to webpack:change
  nuxt.hook('builder:watch', async (pEvent, pShortPath) => {
    if (
      pShortPath.endsWith('models/index.ts') ||
      pShortPath.endsWith('services/index.ts') ||
      pShortPath.endsWith('models/originals.ts') ||
      pShortPath.endsWith('services/originals.ts')
    ) {
      return // Avoid infinite loop
    }
    let type = ''
    if (pShortPath.indexOf('models/') >= 0) {
      type = 'models'
    } else if (pShortPath.indexOf('services/') >= 0) {
      type = 'services'
    } else {
      // Unknown type
      return
    }
    logger.log(
      `[ShopInvader] EVENT - ${pShortPath} ${pEvent} => Checking #${type} index and originals files`
    )
    const content = await buildindexFileContent(nuxt, type)
    await writeFileContent(applicationRoot, type, 'index', content.index)
    await writeFileContent(applicationRoot, type, 'originals', content.originals)
  })
}
